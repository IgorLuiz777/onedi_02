import OpenAI from 'openai';
import { gerarAudioProfessor } from './audioService.js';
import { adicionarVocabulario } from './database.js';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Fun√ß√£o para validar mensagem no modo teste
async function validarMensagemTeste(mensagem, idioma) {
  try {
    const completion = await openai.chat.completions.create({
      model: 'gpt-4',
      messages: [
        {
          role: 'system',
          content: `Voc√™ √© um validador para teste de ${idioma}.

          Analise se a resposta do usu√°rio faz sentido ou √© apenas caracteres aleat√≥rios.

          CRIT√âRIOS PARA RESPOSTA V√ÅLIDA:
          - Cont√©m palavras reais em qualquer idioma
          - Expressa uma ideia, mesmo que simples
          - Pode ter erros (isso √© normal no aprendizado)
          - Tentativa genu√≠na de responder

          CRIT√âRIOS PARA RESPOSTA INV√ÅLIDA:
          - Apenas caracteres aleat√≥rios
          - Sequ√™ncias sem sentido
          - Spam de caracteres

          Responda APENAS:
          V√ÅLIDA - se faz sentido
          INV√ÅLIDA - se √© aleat√≥rio`
        },
        {
          role: 'user',
          content: `Resposta: "${mensagem}"`
        }
      ],
      temperature: 0.1,
      max_tokens: 50
    });

    return completion.choices[0].message.content.trim() === 'V√ÅLIDA';

  } catch (error) {
    console.error('Erro ao validar mensagem teste:', error);
    return true; // Em caso de erro, considera v√°lida
  }
}

// Fun√ß√£o para corrigir e dar feedback
async function corrigirResposta(resposta, idioma, perguntaContexto) {
  try {
    const completion = await openai.chat.completions.create({
      model: 'gpt-4',
      messages: [
        {
          role: 'system',
          content: `Voc√™ √© um professor especialista em ${idioma} dando feedback construtivo.

          INSTRU√á√ïES:
          - Analise a resposta do usu√°rio
          - Identifique erros gramaticais, vocabul√°rio ou estrutura
          - Forne√ßa corre√ß√µes espec√≠ficas e did√°ticas
          - Seja encorajador e positivo
          - Explique o "porqu√™" das corre√ß√µes
          - Use emojis para tornar amig√°vel

          FORMATO DA RESPOSTA:
          ‚úÖ **Pontos Positivos:** [o que est√° correto]

          üîß **Corre√ß√µes Sugeridas:**
          ‚Ä¢ [erro espec√≠fico] ‚Üí [corre√ß√£o] (explica√ß√£o)

          üí° **Vers√£o Melhorada:** [frase corrigida]

          üéØ **Dica:** [dica espec√≠fica para melhorar]`
        },
        {
          role: 'user',
          content: `Idioma: ${idioma}
          Contexto da pergunta: ${perguntaContexto}
          Resposta do usu√°rio: "${resposta}"

          Forne√ßa feedback construtivo e corre√ß√µes.`
        }
      ],
      temperature: 0.7,
      max_tokens: 300
    });

    return completion.choices[0].message.content;

  } catch (error) {
    console.error('Erro ao corrigir resposta:', error);
    return '‚úÖ **Boa tentativa!** Continue praticando para melhorar ainda mais!';
  }
}

// Fun√ß√£o para extrair vocabul√°rio da resposta
async function extrairVocabularioTeste(resposta, usuarioId, idioma) {
  try {
    const completion = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        {
          role: 'system',
          content: `Extraia 2-3 palavras importantes desta resposta em ${idioma} e forne√ßa tradu√ß√µes em portugu√™s.

          Formato: palavra1:tradu√ß√£o1|palavra2:tradu√ß√£o2|palavra3:tradu√ß√£o3
          M√°ximo 3 palavras.`
        },
        {
          role: 'user',
          content: resposta
        }
      ],
      temperature: 0.3,
      max_tokens: 100
    });

    const vocabularioExtraido = completion.choices[0].message.content;
    const pares = vocabularioExtraido.split('|');

    for (const par of pares) {
      const [palavra, traducao] = par.split(':');
      if (palavra && traducao && palavra.trim().length > 1) {
        await adicionarVocabulario(usuarioId, palavra.trim(), traducao.trim(), idioma);
      }
    }
  } catch (error) {
    console.error('Erro ao extrair vocabul√°rio do teste:', error);
  }
}

export class TestModeFlow {
  constructor(usuarioId, idioma, nome, genero) {
    this.usuarioId = usuarioId;
    this.idioma = idioma;
    this.nome = nome;
    this.genero = genero;
    this.perguntaAtual = 0;
    this.maxPerguntas = 10;
    this.interessesDetectados = [];
    this.nivelAtual = 'b√°sico'; // N√≠vel padr√£o
    this.nivelInicial = 'b√°sico'; // N√≠vel definido pelo usu√°rio
    this.historico = [];
    this.threadId = null;
    this.perguntasFeitas = new Set(); // Para evitar repeti√ß√µes
    this.topicosAbordados = new Set(); // Para diversificar t√≥picos
  }

  setNivelInicial(nivel) {
    this.nivelInicial = nivel;
    this.nivelAtual = nivel;
    console.log(`üéØ N√≠vel inicial do teste definido como: ${nivel}`);
  }

  async iniciarTeste() {
    // Incrementa para ir direto para a primeira pergunta
    this.perguntaAtual = 1;

    // Gera a primeira pergunta automaticamente
    return await this.gerarProximaPergunta();
  }

  async processarResposta(resposta, client, user) {
    // Valida se a resposta faz sentido
    const respostaValida = await validarMensagemTeste(resposta, this.idioma);

    if (!respostaValida) {
      const mensagemErro = `‚ùå **Resposta n√£o compreendida**\n\nüß™ **Teste Personalizado:** Detectei que sua resposta pode conter apenas caracteres aleat√≥rios.\n\nüí° **Por favor, responda com palavras reais em ${this.idioma} ou portugu√™s.**\n\nüìù\n\nüéØ **Tente novamente com uma resposta que fa√ßa sentido!**`;

      await this.enviarRespostaComAudio(client, user, mensagemErro);
      return {
        pergunta: this.perguntaAtual,
        nivel: this.nivelAtual,
        interesses: this.interessesDetectados,
        continuar: true,
        respostaInvalida: true
      };
    }

    // Gera corre√ß√£o e feedback da resposta
    const ultimaPergunta = this.historico.length > 0 ?
      this.historico[this.historico.length - 1]?.pergunta || 'pergunta anterior' :
      'pergunta anterior';

    const correcao = await corrigirResposta(resposta, this.idioma, ultimaPergunta);

    // Extrai vocabul√°rio da resposta
    await extrairVocabularioTeste(resposta, this.usuarioId, this.idioma);

    // Detecta interesses na resposta
    await this.detectarInteresses(resposta);

    // Salva no hist√≥rico
    this.historico.push({
      pergunta: this.perguntaAtual,
      resposta: resposta,
      nivel: this.nivelAtual,
      timestamp: new Date()
    });

    // Incrementa pergunta
    this.perguntaAtual++;

    // Verifica se terminou o teste
    if (this.perguntaAtual > this.maxPerguntas) {
      return await this.finalizarTeste(client, user);
    }

    // Gera pr√≥xima pergunta personalizada
    const proximaPergunta = await this.gerarProximaPergunta();

    // Envia corre√ß√£o/feedback primeiro (SEM √°udio)
    await client.sendText(user, `üìù **Feedback da sua resposta:**\n\n${correcao}`);

    // Envia pr√≥xima pergunta (COM √°udio)
    setTimeout(async () => {
      await this.enviarRespostaComAudio(client, user, proximaPergunta.pergunta);
    }, 2000);

    return {
      pergunta: this.perguntaAtual,
      nivel: this.nivelAtual,
      interesses: this.interessesDetectados,
      continuar: true
    };
  }

  async detectarInteresses(resposta) {
    try {
      const completion = await openai.chat.completions.create({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: `Analise a resposta do usu√°rio e identifique at√© 3 interesses/temas principais mencionados.

            Categorias poss√≠veis:
            - Trabalho/Carreira (business, job, work, career)
            - Viagens (travel, countries, places, vacation)
            - Tecnologia (technology, computers, internet, apps)
            - Esportes (sports, football, basketball, gym, fitness)
            - M√∫sica (music, songs, instruments, concerts)
            - Comida (food, cooking, restaurants, cuisine)
            - Fam√≠lia (family, children, parents, relationships)
            - Estudos (education, school, university, learning)
            - Entretenimento (movies, TV, games, books)
            - Sa√∫de (health, medicine, wellness, exercise)
            - Arte (art, painting, drawing, creativity)
            - Natureza (nature, animals, environment, outdoors)

            Responda apenas com os interesses detectados separados por v√≠rgula.
            Exemplo: trabalho, tecnologia, viagens`
          },
          {
            role: 'user',
            content: resposta
          }
        ],
        temperature: 0.3,
        max_tokens: 50
      });

      const novosInteresses = completion.choices[0].message.content
        .split(',')
        .map(interesse => interesse.trim().toLowerCase())
        .filter(interesse => interesse.length > 2);

      // Adiciona novos interesses sem duplicar
      novosInteresses.forEach(interesse => {
        if (!this.interessesDetectados.includes(interesse)) {
          this.interessesDetectados.push(interesse);
        }
      });

    } catch (error) {
      console.error('Erro ao detectar interesses:', error);
    }
  }

  async gerarProximaPergunta() {
    // Determina n√≠vel baseado na pergunta atual
    // Ajusta n√≠vel baseado no n√≠vel inicial selecionado pelo usu√°rio
    if (this.nivelInicial === 'iniciante') {
      if (this.perguntaAtual <= 4) {
        this.nivelAtual = 'iniciante';
      } else if (this.perguntaAtual <= 8) {
        this.nivelAtual = 'b√°sico';
      } else {
        this.nivelAtual = 'intermedi√°rio';
      }
    } else if (this.nivelInicial === 'b√°sico') {
      if (this.perguntaAtual <= 3) {
        this.nivelAtual = 'b√°sico';
      } else if (this.perguntaAtual <= 7) {
        this.nivelAtual = 'intermedi√°rio';
      } else {
        this.nivelAtual = 'avan√ßado';
      }
    } else if (this.nivelInicial === 'intermedi√°rio') {
      if (this.perguntaAtual <= 3) {
        this.nivelAtual = 'intermedi√°rio';
      } else {
        this.nivelAtual = 'avan√ßado';
      }
    } else if (this.nivelInicial === 'avan√ßado') {
      this.nivelAtual = 'avan√ßado'; // Mant√©m sempre avan√ßado
    }

    const interessesTexto = this.interessesDetectados.length > 0
      ? this.interessesDetectados.join(', ')
      : 'temas gerais';

    // Lista de t√≥picos diversos para evitar repeti√ß√£o
    const topicosDiversos = [
      'hobbies e tempo livre',
      'trabalho e carreira',
      'fam√≠lia e relacionamentos',
      'viagens e lugares',
      'comida e culin√°ria',
      'tecnologia e internet',
      'esportes e exerc√≠cios',
      'm√∫sica e entretenimento',
      'estudos e educa√ß√£o',
      'sa√∫de e bem-estar',
      'natureza e meio ambiente',
      'arte e cultura',
      'rotina di√°ria',
      'planos futuros',
      'experi√™ncias passadas'
    ];

    // Seleciona um t√≥pico que ainda n√£o foi usado
    const topicosDisponiveis = topicosDiversos.filter(topico => !this.topicosAbordados.has(topico));
    const topicoEscolhido = topicosDisponiveis.length > 0
      ? topicosDisponiveis[Math.floor(Math.random() * topicosDisponiveis.length)]
      : topicosDiversos[Math.floor(Math.random() * topicosDiversos.length)];

    this.topicosAbordados.add(topicoEscolhido);

    try {
      const completion = await openai.chat.completions.create({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: `Voc√™ est√° conduzindo um teste personalizado de ${this.idioma} para ${this.nome}.

            CONTEXTO:
            - Pergunta atual: ${this.perguntaAtual}/10
            - N√≠vel atual: ${this.nivelAtual}
            - Interesses detectados: ${interessesTexto}
            - Idioma: ${this.idioma}
            - T√≥pico para esta pergunta: ${topicoEscolhido}

            INSTRU√á√ïES IMPORTANTES:
            1. Crie uma PERGUNTA √öNICA sobre "${topicoEscolhido}"
            2. NUNCA repita perguntas j√° feitas anteriormente
            3. A pergunta deve ser apropriada para o n√≠vel atual (${this.nivelAtual})
            4. Use vocabul√°rio e estruturas adequadas ao n√≠vel
            5. Varie o tipo de pergunta (opini√£o, experi√™ncia, descri√ß√£o, compara√ß√£o)
            6. Torne a pergunta interessante e envolvente

            N√çVEIS:
            - Iniciante: Perguntas muito simples, vocabul√°rio b√°sico, presente
            - B√°sico: Perguntas simples, presente, vocabul√°rio fundamental
            - Intermedi√°rio: Estruturas mais complexas, passado/futuro, opin√µes
            - Avan√ßado: Discuss√µes abstratas, subjuntivo, argumenta√ß√£o

            FORMATO DA RESPOSTA:
            PERGUNTA: [pergunta personalizada em ${this.idioma}]

            TRADU√á√ÉO: [tradu√ß√£o da pergunta em portugu√™s]

            DICA: [dica √∫til sobre vocabul√°rio ou gram√°tica]`
          },
          {
            role: 'user',
            content: `Gere a pergunta ${this.perguntaAtual} sobre o t√≥pico: ${topicoEscolhido}

            IMPORTANTE: Esta pergunta deve ser DIFERENTE de todas as anteriores.

            Perguntas j√° feitas (EVITE repetir):
            ${this.historico.map(h => `P${h.pergunta}: ${h.resposta.substring(0, 100)}...`).join('\n')}

            N√≠vel inicial selecionado pelo usu√°rio: ${this.nivelInicial}
            N√≠vel atual da pergunta: ${this.nivelAtual}

            Crie uma pergunta completamente nova e √∫nica sobre "${topicoEscolhido}".`
          }
        ],
        temperature: 0.7,
        max_tokens: 300,
        ...(this.threadId ? { thread_id: this.threadId } : {})
      });

      const resposta = completion.choices[0].message.content;

      // Salva thread_id para manter contexto
      if (!this.threadId && completion.thread_id) {
        this.threadId = completion.thread_id;
      }

      // Adiciona a pergunta ao conjunto de perguntas feitas
      this.perguntasFeitas.add(resposta.toLowerCase());

      return {
        pergunta: `üìö **Pergunta ${this.perguntaAtual}/10** (N√≠vel: ${this.nivelAtual})\nüìù **T√≥pico:** ${topicoEscolhido}\n\n${resposta.trim()}`
      };

    } catch (error) {
      console.error('Erro ao gerar pergunta:', error);

      // Pergunta de fallback √∫nica baseada no t√≥pico
      const perguntasFallback = {
        'hobbies e tempo livre': `Quais s√£o seus hobbies favoritos e por qu√™?`,
        'trabalho e carreira': `Descreva seu trabalho ideal em ${this.idioma}.`,
        'fam√≠lia e relacionamentos': `Como √© sua fam√≠lia? Conte sobre eles.`,
        'viagens e lugares': `Qual lugar voc√™ gostaria de visitar e por qu√™?`,
        'comida e culin√°ria': `Qual √© sua comida favorita? Descreva-a.`,
        'tecnologia e internet': `Como a tecnologia mudou sua vida?`,
        'esportes e exerc√≠cios': `Voc√™ pratica algum esporte? Conte sobre isso.`,
        'm√∫sica e entretenimento': `Que tipo de m√∫sica voc√™ gosta? Por qu√™?`,
        'estudos e educa√ß√£o': `Por que voc√™ est√° aprendendo ${this.idioma}?`,
        'sa√∫de e bem-estar': `O que voc√™ faz para manter-se saud√°vel?`
      };

      const perguntaFallback = perguntasFallback[topicoEscolhido] || `Conte-me sobre ${topicoEscolhido} em sua vida.`;

      return {
        pergunta: `üìö **Pergunta ${this.perguntaAtual}/10** (N√≠vel: ${this.nivelAtual})\nüìù **T√≥pico:** ${topicoEscolhido}\n\n${perguntaFallback}`
      };
    }
  }

  async enviarRespostaComAudio(client, user, texto) {
    try {
      // Envia texto
      await client.sendText(user, texto);

      // Gera e envia √°udio automaticamente
      const nomeArquivo = `test_audio_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const audioBuffer = await gerarAudioProfessor(
        texto,
        this.idioma,
        nomeArquivo,
        this.genero
      );

      const audioBase64 = Buffer.from(audioBuffer).toString('base64');
      await client.sendPttFromBase64(user, audioBase64);

    } catch (error) {
      console.error('Erro ao enviar resposta com √°udio:', error);
      // Se falhar o √°udio, pelo menos envia o texto
      await client.sendText(user, texto);
    }
  }

  async finalizarTeste(client, user) {
    const interessesResumo = this.interessesDetectados.length > 0
      ? this.interessesDetectados.slice(0, 3).join(', ')
      : 'diversos temas';

    const mensagemFinal = `üéâ **Parab√©ns, ${this.nome}! Teste Conclu√≠do!**

üèÜ **Sua Jornada Personalizada foi Incr√≠vel!**

üìä **Resumo da sua Experi√™ncia:**
‚Ä¢ ‚úÖ **10 perguntas** respondidas com sucesso
‚Ä¢ üìà **Progress√£o:** B√°sico ‚Üí Intermedi√°rio ‚Üí Avan√ßado
‚Ä¢ ü§ñ **IA Adaptativa:** Perguntas personalizadas em tempo real
‚Ä¢ üîä **√Åudio HD:** Text-to-speech de alta qualidade
‚Ä¢ üé§ **Speech-to-Text:** Reconhecimento de voz avan√ßado

üöÄ **Continue sua Jornada com a ONEDI!**
üíé **Planos Personalizados Dispon√≠veis!**

üåê **Acesse nosso site oficial:**
üëâ https://onedi-lp.vercel.app/

üí° **Para personalizar seu plano, digite /personalizar**

üí° **Obrigado por experimentar a ONEDI - onde a IA encontra a educa√ß√£o!**`;

    await this.enviarRespostaComAudio(client, user, mensagemFinal);

    return {
      testeConcluido: true,
      interessesDetectados: this.interessesDetectados,
      perguntasRespondidas: this.maxPerguntas,
      nivelFinal: this.nivelAtual
    };
  }

  getProgresso() {
    return {
      perguntaAtual: this.perguntaAtual,
      totalPerguntas: this.maxPerguntas,
      porcentagem: Math.round((this.perguntaAtual / this.maxPerguntas) * 100),
      nivel: this.nivelAtual,
      interesses: this.interessesDetectados
    };
  }
}

export const sessoesTesteModo = new Map();

export function iniciarTesteModo(usuarioId, idioma, nome, genero) {
  const sessao = new TestModeFlow(usuarioId, idioma, nome, genero);
  sessoesTesteModo.set(usuarioId, sessao);
  return sessao;
}

export function obterSessaoTeste(usuarioId) {
  return sessoesTesteModo.get(usuarioId);
}

export function finalizarSessaoTeste(usuarioId) {
  sessoesTesteModo.delete(usuarioId);
}
